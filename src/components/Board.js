import React, { useEffect, useState } from 'react';
import { Tldraw, useEditor } from 'tldraw';
import 'tldraw/tldraw.css';
import ACTIONS from '../Actions';
import toast from 'react-hot-toast';


// Error Boundary Component
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, error: null, errorInfo: null };
    }

    static getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
        console.error("Whiteboard Error:", error, errorInfo);
        this.setState({ error, errorInfo });
    }

    render() {
        if (this.state.hasError) {
            return (
                <div style={{ padding: 20, color: 'white' }}>
                    <h2>Whiteboard Error</h2>
                    <p>Something went wrong with the whiteboard.</p>
                    <details style={{ whiteSpace: 'pre-wrap' }}>
                        {this.state.error && this.state.error.toString()}
                    </details>
                </div>
            );
        }

        return this.props.children;
    }
}

const Board = ({ socketRef, roomId }) => {
    const [editor, setEditor] = useState(null);
    const socket = socketRef?.current;

    // Handle Editor Mount
    const handleMount = (editorInstance) => {
        console.log('Board: handleMount called');
        setEditor(editorInstance);
    };

    useEffect(() => {
        console.log('Board: useEffect running', { editor: !!editor, socket: !!socket, roomId });
        if (!editor || !socket) return;
        console.log('Board: Attaching listeners', socket.id);

        /* 
        // TEMPORARILY DISABLED: Testing if socket logic causes crash
        // Listener for local changes
        const cleanupListener = editor.store.listen((update) => {
            // console.log('Board: Update received', update);
            // Only emit updates generated by the user
            if (update.source === 'user') {
                const { added, updated, removed } = update.changes;

                const updatedToSend = {};
                for (const [id, [from, to]] of Object.entries(updated)) {
                    updatedToSend[id] = to;
                }

                const changesToSend = {
                    added,
                    updated: updatedToSend,
                    removed
                };

                // serialize changes to send over socket
                // console.log('Board: Emitting changes');
                if (socket && socket.connected) {
                    socket.emit(ACTIONS.DRAWING_UPDATE, {
                        roomId,
                        changes: changesToSend
                    });
                }
            }
        });

        // Listener for remote updates
        const handleRemoteUpdate = ({ changes }) => {
            // console.log('Board: Received remote changes', changes);
            if (changes) {
                // Apply remote changes manually to avoid mergeRemoteChanges error
                try {
                    const { added, updated, removed } = changes;

                    editor.store.mergeRemoteChanges(() => {
                        if (added && Object.keys(added).length > 0) {
                            editor.store.put(Object.values(added));
                        }
                        if (updated && Object.keys(updated).length > 0) {
                            // updated is already sanitized to { id: record } from the emitter
                            editor.store.put(Object.values(updated));
                        }
                        if (removed && Object.keys(removed).length > 0) {
                            editor.store.remove(Object.values(removed).map(r => r.id));
                        }
                    });
                    // toast.success('Synced');
                } catch (err) {
                    console.error('Whiteboard: Error applying remote changes', err);
                    toast.error(`Sync Error: ${err.message}`);
                }
            }
        };

        socket.on(ACTIONS.DRAWING_UPDATE, handleRemoteUpdate);

        return () => {
            cleanupListener();
            socket.off(ACTIONS.DRAWING_UPDATE, handleRemoteUpdate);
        };
        */

        // Temporary dummy return to match expected types if needed, though cleanup function is optional
        return () => { };
    }, [editor, socket, roomId]);

    return (
        <div style={{ position: 'absolute', inset: 0, width: '100%', height: '100%' }}>
            <ErrorBoundary>
                <Tldraw
                    onMount={handleMount}
                    options={{ maxPages: 1 }} // Limit to 1 page for simplicity
                    persistenceKey={roomId} // Use roomId to separate state and avoid corruption
                />
            </ErrorBoundary>
        </div>
    );
};

export default Board;
